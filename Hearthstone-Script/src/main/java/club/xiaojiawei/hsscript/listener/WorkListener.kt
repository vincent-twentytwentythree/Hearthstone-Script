package club.xiaojiawei.hsscript.listener

import club.xiaojiawei.bean.LRunnable
import club.xiaojiawei.config.EXTRA_THREAD_POOL
import club.xiaojiawei.config.log
import club.xiaojiawei.hsscript.core.Core
import club.xiaojiawei.hsscript.enums.ConfigEnum
import club.xiaojiawei.hsscript.status.PauseStatus
import club.xiaojiawei.hsscript.utils.ConfigExUtil
import club.xiaojiawei.hsscript.utils.ConfigUtil
import club.xiaojiawei.hsscript.utils.GameUtil
import club.xiaojiawei.hsscript.utils.SystemUtil
import club.xiaojiawei.hsscript.data.GAME_REGION
import javafx.beans.property.SimpleBooleanProperty
import javafx.beans.property.SimpleDoubleProperty
import java.time.LocalDate
import java.time.LocalTime
import java.util.concurrent.ScheduledFuture
import java.util.concurrent.TimeUnit

/**
 * Â∑•‰ΩúÁä∂ÊÄÅ
 *
 * @author ËÇñÂòâÂ®Å
 * @date 2023/9/10 22:04
 */
object WorkListener {

    private var checkVersionTask: ScheduledFuture<*>? = null

    fun launch() {
        checkVersionTask?.let { return }
        checkVersionTask = EXTRA_THREAD_POOL.scheduleAtFixedRate(LRunnable {
            checkWork()
        }, 0, 1000 * 60, TimeUnit.MILLISECONDS)
        log.info { "Â∑•‰ΩúÊó∂ÊÆµÁõëÂê¨Â∑≤ÂêØÂä®" }
    }

    /**
     * ÊòØÂê¶Â§Ñ‰∫éÂ∑•‰Ωú‰∏≠
     */
    val workingProperty = SimpleBooleanProperty(false)

    var working: Boolean
        get() = workingProperty.get()
        set(value) = workingProperty.set(value)

    private var enableUpdate = true

    @Synchronized
    fun stopWork() {
        workingProperty.set(false)
        cannotWorkLog()
        log.info { "ÂÅúÊ≠¢Â∑•‰ΩúÔºåÂáÜÂ§áÂÖ≥Èó≠Ê∏∏Êàè" }
        GameUtil.killGame()
    }

    fun cannotWorkLog() {
        val context = "Áé∞Âú®ÊòØ‰∏ãÁè≠Êó∂Èó¥ üåú"
        SystemUtil.notice(context)
        log.info { context }
    }

    fun workLog() {
        log.info { "Áé∞Âú®ÊòØ‰∏äÁè≠Êó∂Èó¥ üåû" }
    }

    fun checkWork() {
        if (working) return
        synchronized(workingProperty) {
            if (working) return
            if (!PauseStatus.isPause && isDuringWorkDate()) {
                workLog()
                Core.start()
            } else if (enableUpdate && ConfigUtil.getBoolean(ConfigEnum.AUTO_UPDATE) && VersionListener.canUpdate) {
                enableUpdate = false
                val progress = SimpleDoubleProperty()
                VersionListener.downloadLatestRelease(false, progress) { path ->
                    path?.let {
                        VersionListener.execUpdate(path)
                    } ?: let {
                        enableUpdate = true
                    }
                }
            }
        }
    }

    /**
     * È™åËØÅÊòØÂê¶Âú®Â∑•‰ΩúÊó∂Èó¥ÂÜÖ
     *
     * @return
     */
    fun isDuringWorkDate(): Boolean { // MYWEN
        //        Â§©Ê†°È™å
        var workDay = ConfigExUtil.getWorkDay()
        val nowDay = LocalDate.now().getDayOfWeek().value
        if (workDay.isNotEmpty()) {
            if (!(workDay[0].enabled || workDay[nowDay].enabled)) {
                return false
            }
        } else {
            return false
        }

        //        ÊÆµÊ†°È™å
        var workTime = ConfigExUtil.getWorkTime().toList()
        val nowTime: LocalTime = LocalTime.now()
        GAME_REGION = 0
        for (time in workTime) {
            if (time.enabled) {
                val startTime = time.parseStartTime()
                val endTime = time.parseEndTime()
                if (startTime == endTime) {
                    return true
                }
                if (startTime != null && startTime.isBefore(nowTime) && (endTime == null || endTime.isAfter(nowTime))) {
                    return true
                }

                if (endTime != null && endTime.isAfter(nowTime) && (startTime == null || startTime.isBefore(nowTime))) {
                    return true
                }
            }
            GAME_REGION = GAME_REGION + 1
        }
        return false
    }

}
